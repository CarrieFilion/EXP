#!/usr/bin/python

# -*- coding: utf-8 -*-

"""Program to compute the energy distributions based on the DSMC_log
file data

Examples:

	$ python ion_dist.py -f electron run2

Plots the energy distributions for the named field (in the case above,
electrons) for the run with tag "run2".  Field value is "electron" by
default.  Other fields are "ion" and "interact" for the electron-ion
interaction kinetic energy.

"""

import re, sys, copy, getopt
import numpy as np
import matplotlib.pyplot as plt
import numpy as np
from scipy.optimize import curve_fit


def func(x, a, b):
    """Fit energy distribution for amplitude and temperature"""
    if a<=0.0: return 1e30
    if b<=0.0: return 1e30
    return a * np.sqrt(x) * np.exp(-b * x) / b**1.5

def plot_data(runtag, field, defaultT, until, deltaT, Z):
    """Parse and plot the *.DSMC_log output files generated by CollideIon 
 
    Parameters:

    filename (string): is the input datafile name

    field (string): is either "electron", "ion" or "interact"

    defaultT (float): is the default temperature (probably not needed
    in most cases)

    until (float): skips all data until current time of <until> is
    reached

    deltaT (float): offset in temperature from current temperature for
    comparison with expected distributions for a pure
    Maxwell-Boltzmann distribution

    Z (int): atomic element for ion distribution

    """

    #
    # Patterns
    #
    num = '([0-9.+\-e]+)'
    beg = '^[\[ ]+'
    end = '[\] ]+'
    sep = '[, ]+'
    bar = '[\]| =]+'
    pattern = beg + num + sep + num + end + bar + num

    if field == "electron" and Z==0:
        fpat = '.*Electron energy.*'
    elif field == "ion" and Z==0:
        fpat = '.*Ion energy.*'
    elif field == "electron" and Z>0:
        fpat = ".*Electron \(Z={}\) energy.*".format(Z)
    elif field == "ion" and Z>0:
        fpat = ".*Ion \(Z={}\) energy.*".format(Z)
    elif field == "interact":
        fpat = '.*Electron interaction energy.*'
    else:
        print "Bad field.  Allowed fields are: electron, ion, interact"
        return

    #
    # Regex compilations
    #
    prog = re.compile(pattern)
    begn = re.compile(fpat)
    ctim = re.compile('^[ ]+' + num + '[ ]+' + 'current time')
    clev = re.compile('^[ ]+' + num + '[ ]+' + 'current level')
    temp = re.compile('^[ ]+' + num + '[ ]+' + 'mass-weighted temperature')

    file = open(runtag + ".DSMC_log")

    look = False

    #
    # Plotting data
    #
    xb = []
    xe = []
    xx = []
    yy = []

    #
    # Default time
    #
    time = 0.0
    
    slopeFac = 11604.50560112828
    slope = slopeFac/defaultT
    level = 0
    
    for line in file:
        #
        # Look for current time
        #
        result = ctim.match(line)
        if result is not None:
            time = float(result.group(1))
        #
        # Look for current temp
        #
        result = temp.match(line)
        if result is not None:
            ttemp = float(result.group(1))
            if ttemp>0.0:
                defaultT = ttemp
                slope = slopeFac/defaultT
        #
        # Look for current level
        #
        result = clev.match(line)
        if result is not None:
            level = int(result.group(1))
        #
        # If in a desired stanza, look for data
        #
        if look:
            result = prog.match(line)
            if result is not None:
                if len(result.groups()) == 3:
                    xb.append(float(result.group(1)))
                    xe.append(float(result.group(2)))
                    xx.append(0.5*(xb[-1]+xe[-1]))
                    yy.append(float(result.group(3)) + 0.1)
            elif len(xb)>0:         # End of data: make the plot
                # Fit for temperature
                popt, pcov = curve_fit(func, xx, yy)
                # Temp
                bT = slopeFac / popt[1]
                # Make curves
                tt = []
                for v in xx: tt.append(func(v, popt[0], popt[1]))
                lt = []
                for v in tt: lt.append(np.log(v))
                #
                ly = []
                for v in yy: ly.append(np.log(v))

                fig, axes = plt.subplots(nrows=2, ncols=1)

                ax = axes[0]
                ax.plot(xx, ly, '-o')
                ax.plot(xx, lt, '-')

                if Z>0:
                    ax.set_title("{} (Z={}): t={} T(fit)={} T={}".format(field, Z,time,bT,ttemp))
                else:
                    ax.set_title("{}: t={} T(fit)={} T={}".format(field,time,bT,ttemp))
                ax.set_ylabel("Log(counts)")
                ax.tick_params(axis='x', labelbottom='off')

                ay = axes[1]
                ay.plot(xx, yy, '-o')
                ay.plot(xx, tt, '-')

                ay.set_xlabel("Energy (eV)")
                ay.set_ylabel("Counts")
                
                fig.tight_layout()
                plt.show()
                look = False
        else:                       # Look for beginning of stanza
            result = begn.match(line)
            if result is not None and time >= until and level==0:
                xb = []             # Zero out data
                xe = []
                xx = []
                yy = []
                look = True

def main(argv):
    """ Parse the command line and call the parsing and plotting routine """

    field = "electron"
    until = 0.0
    defT  = 100000.0
    delta = 0.2
    Z     = 0

    options = '[-f <field> | --field=<field> | -t <initial time> | --time=<initial time> | -T <temp> | --temp=<temp> | -d <delta> | --delta=<delta> | -Z <Z> | --Z <Z>] <runtag>'

    try:
        opts, args = getopt.getopt(argv,"hf:T:t:d:Z:", ["help","field=","temp=","time=","delta=","Z="])
    except getopt.GetoptError:
        print sys.argv[0], 
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            print sys.argv[0], options
            sys.exit()
        elif opt in ("-f", "--field"):
            field = arg
        elif opt in ("-T", "--temp"):
            defT = float(arg)
        elif opt in ("-t", "--time"):
            until = float(arg)
        elif opt in ("-d", "--delta"):
            delta = float(arg)
        elif opt in ("-Z", "--Z"):
            Z = int(arg)

    if len(args)>0:
        filename = args[0]
    else:
        filename = "run"

    plot_data(filename, field, defT, until, delta, Z)

if __name__ == "__main__":
   main(sys.argv[1:])
                
