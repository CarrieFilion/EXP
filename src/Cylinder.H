#ifndef _Cylinder_H
#define _Cylinder_H

#include <Vector.h>
#include <Orient.H>
#include <Basis.H>
#include <EmpCylSL.h>
#include <CylindricalCoefs.H>

#include "config.h"

#if HAVE_LIBCUDA==1
#include <cudaParticle.cuH>
#include <cudaMappingConstants.cuH>
#endif
#include <NVTX.H>

class MixtureBasis;

/** This routine computes the potential, acceleration and density 
    using the Cylindrical biorthogonal expansion 
*/
class Cylinder : public Basis
{
private:

  bool expcond, EVEN_M;
  int rnum, pnum, tnum;
  double ashift;
  unsigned int vflag;

  EmpCylSL *ortho;
  int eof, ncompcyl;
  double cylmass, resetT;

  // Three_Vector *pos, *frc;
  Vector *pos, *frc;

  std::vector<double> cylmass0;
  std::vector<int> offgrid;

  void initialize(void);

				// Parameters
  double rcylmin, rcylmax, zmax, acyl;
  int nmax, lmax, mmax, mlim;
  int ncylnx, ncylny, ncylr;
  double hcyl;
  int ncylorder, ncylrecomp, npca, npca0, nvtk, cmaptype;
  string eof_file;
  bool self_consistent, logarithmic, density, pcavar, pcainit, pcavtk, pcadiag, pcaeof, eof_over, cmap;
  bool try_cache, firstime, dump_basis, compute, firstime_coef;

  // These should be ok for all derived classes, hence declared private

  void determine_coefficients();

  void determine_coefficients_eof();

  void determine_acceleration_and_potential();

  void * determine_coefficients_thread(void * arg);

  void * determine_acceleration_and_potential_thread(void * arg);

  /** Extrapolate and sum coefficents per multistep level to get
      a complete set of coefficients for force evaluation at an
      intermediate time step
  */
  void compute_multistep_coefficients() 
  {
    nvTracerPtr tPtr;
    if (cuda_prof)
      tPtr = nvTracerPtr(new nvTracer("Cylinder::compute_multistep_coefficients"));
    ortho->compute_multistep_coefficients(mfirst[mstep]);
  }

  //! Reset used particle counter and mass registers
  virtual void multistep_reset();

  //! For massive satellite simulations
  MixtureBasis *mix;

protected:

  //! CUDA method for coefficient accumulation
#if HAVE_LIBCUDA==1
  virtual void determine_coefficients_cuda(bool compute_pca);
  virtual void determine_acceleration_cuda();

  thrust::host_vector  <cuFP_t> host_coefs, host_massT;
  thrust::device_vector<cuFP_t> dev_coefs;
  std::vector<thrust::host_vector<cuFP_t>> host_coefsT;

  int sampT;

  virtual void HtoD_coefs();
  virtual void DtoH_coefs(int mlevel);

  std::vector<cudaArray_t> cuInterpArray;
  thrust::host_vector<cudaTextureObject_t> tex;

  bool initialize_cuda_cyl;

  virtual void initialize_cuda()
  {
    sampT = floor(sqrt(component->CurTotal()));
    ortho->initialize_cuda(cuInterpArray, tex);
  }

  virtual cudaMappingConstants getCudaMappingConstants()
  {
    return ortho->getCudaMappingConstants();
  }

  virtual void destroy_cuda();

  virtual void initialize_mapping_constants();

  //! Compare CPU and GPU force evaluation for debugging
  void host_dev_force_compare();

  //@{
  //! Working device vectors
  thrust::device_vector<cudaTextureObject_t> t_d;

  //! Helper struct to hold device data
  struct cudaStorage
  {
    thrust::device_vector<cuFP_t> dN_coef;
    thrust::device_vector<cuFP_t> dc_coef;
    thrust::device_vector<cuFP_t> dw_coef;
    thrust::device_vector<cuFP_t> df_coef;
    thrust::device_vector<cuFP_t> X_d, Y_d, m_d, u_d, p_d;
    thrust::device_vector<int   > iX_d, iY_d;

    std::vector<thrust::device_vector<cuFP_t>> T_coef;

    thrust::device_vector<cuFP_t> dN_tvar;
    thrust::device_vector<cuFP_t> dc_tvar;
    thrust::device_vector<cuFP_t> dw_tvar;
    thrust::device_vector<cuFP_t> df_tvar;

    void resize_coefs(int ncylorder, int mmax, int N, int gridSize, int sampT, bool pcavar, bool pcaeof);
  };

  //! Cyclical ring interator for storage
  //@{
  //! An STL container
  typedef std::vector<cudaStorage> cuContainer;

  //! An iterator for the container
  typedef cuContainer::iterator    cuIterator;

  //! Convert to a ring iterator
  typedef RingIterator <cudaStorage, cuContainer, cuIterator> cuRingType;

  //! The storage instance
  cuContainer cuRingData;

  //! The cyclic iterator instance
  boost::shared_ptr<cuRingType> cuRing;
  //@}
  
  //! Initialize the container
  void cuda_initialize();

  //! Zero the coefficient output vectors
  void zero_coefs();

  //@}


#endif

  /** Coefficient playback instance.  Using shared_ptr to avoid
      constructing a simple pointer or null instance
  */
  std::shared_ptr<CylindricalCoefs> playback;

  /** Master node ships coefficients to hosts.  True (default) implies
      that only the master node caches the coefficients for playback
      to save core memory.  This is set in the config input using the
      'coefMaster: bool' parameter. Once I am sure that there are no
      algorithmic issues, I will remove this as an option.
  */
  bool coefMaster;

  //! Last playback coefficient evaluation time
  double lastPlayTime;

public:

  //! Mutexes for multithreading
  //@{
  static pthread_mutex_t used_lock, cos_coef_lock, sin_coef_lock;
  //@}

  //! Constructor
  //! \param conf contains the parameters passed to the method
  //! \param m is the MixtureBasis for a multicenter expansion
  //! 
  //! Parameters settable in the configuration line include:
  //! \param acyl is the disk scale length for the basis
  //! \param hcyl is the disk scale height for the basis
  //! \param nmax is the radial order for the underlying spherical basis
  //! \param lmax is the harmonic order for the underlying spherical basis
  //! \param mmax is the azimuthal harmonic order for final cylindrical expansion
  //! \param mlim restricts the azimuthal harmonic order for testing
  //! \param ncylnx is the radial grid in the basis function table
  //! \param ncylny is the vertical grid in the basis function table
  //! \param ncylr is the size of the spherical radial grid used to construct the cylindrical basis
  //! \param ncylrecomp is the number of steps between basis recomputation (default: -1 which means NEVER)
  //! \param npca is the number of steps between Hall coefficient recomputaton 
  //! \param npca0 is the first step for Hall coefficient computaton 
  //! \param nvtk is the number of step VTK output 
  //! \param pcadiag set to true enables PCA output diagnostics (default: false)
  //! \param eof_file is an override for the default EOF cache file name
  //! \param vflag sets verbosity (see EmpCylSL.cc)
  //! \param rnum is the number of Legendre radial knots for numerical basis computation
  //! \param pnum is the number of azimuthal knots for numerical basis computation
  //! \param tnum is the number of Legendre polar knots for numerical basis computation
  //! \param ashift is the shift applied in the x-axis relative to the original for basis conditioning
  //! \param self_consistent set to false for fixed potential
  //! \param expcond set to true for analytic basis function conditioning (default: true)
  //! \param logr tabulate basis in logarithmic coordinates (default: false)
  //! \param pcavar set to true for real-time Hall analysis (default: false)
  //! \param pcavtk set to true dumps PCA functions in VTK format for diagnostics (default: false)
  //! \param try_cache set to true means try to read basis from cache (default: true)
  //! \param dump_basis set to true outputs basis into file
  //! \param density set to true means compute density basis in addition to potential (default: false)
  //! \param cmap selects the coordinate mapping (default: 2, power mapping)
  //!
  Cylinder(const YAML::Node& conf, MixtureBasis *m=0);

  //! Destructor
  virtual ~Cylinder();
  
  //! The main force call
  void get_acceleration_and_potential(Component*);

  //! Return the value for the fields at a spherical polar coordinate
  void 
  determine_fields_at_point_sph(double r, double theta, double phi,
				double *tdens0, double *tpotl0, 
				double *tdens, double *tpotl, 
				double *tpotr, double *tpott, 
				double *tpotp);

  //! Return the value for the fields at a cylindrical coordinate
  void 
  determine_fields_at_point_cyl(double r, double z, double phi,
				double *tdens0, double *tpotl0, 
				double *tdens, double *tpotl, 
				double *tpotr, double *tpotz, 
				double *tpotp);

  /** Update the multi time step coefficient table when moving particle 
      <code>i</code> from level <code>cur</code> to level 
      <code>next</code>.
  */
  //@{
  virtual void multistep_update_begin() { 
    if (play_back) return;
    if (self_consistent) ortho->multistep_update_begin();
  }

  virtual void multistep_update(int cur, int next, Component* c, int i, int id);
  virtual void multistep_update_finish() { 
    if (play_back) return;
    if (self_consistent) ortho->multistep_update_finish();
  }
  //@}

  //! Print debug info
  virtual void multistep_debug();

  //! Save coefficients to file (need type marker to id dump, component id?)
  void dump_coefs(ostream& out);

  //! Sanity check on grid: dumps SM-style images of initial field
  void dump_mzero(const string& name, int step);

};


#endif
